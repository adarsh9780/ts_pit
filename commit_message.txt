feat(agent_v3): add direct-answer routing and SQL-first execution guardrails

Implements planner-driven no-tool responses for state-only questions and
strengthens execution safety/preference for backend data retrieval via SQL.

Changes:
- backend/agent_v3/state.py
  - add `plan_requires_execution: bool` to runtime state
- backend/agent_v3/planning.py
  - extend planner output model with `requires_execution`
  - add deterministic direct-state question detection (selected/current alert)
    and force `requires_execution=false` for those requests
  - when execution is not required, archive/skip unresolved pending steps to
    prevent stale tool execution on follow-up questions
  - tighten SQL-intent keyword detection to reduce false positives
  - include `plan_requires_execution` in planner state updates
- backend/agent_v3/prompts/planner.yaml
  - require planner to output `requires_execution`
  - document no-tool path when current context/prior outputs are sufficient
- backend/agent_v3/graph.py
  - master routes directly to `respond` when `plan_requires_execution=false`
  - responder now receives current alert context JSON
- backend/agent_v3/prompts/execution.yaml
  - add explicit policy: prefer execute_sql for backend retrieval, execute_python
    mainly for post-fetch analysis, avoid full-table reads, avoid SELECT *
- backend/agent_v3/execution.py
  - add deterministic tool bias:
    - force execute_sql first for retrieval-style steps
    - prefer execute_python for analysis-style steps only when prior data exists
- backend/agent_v3/tools.py
  - enforce bounded SQL results by auto-appending `LIMIT 200` when missing
  - return `query_auto_limited` metadata and executed bounded query

Validation:
- `python3 -m py_compile` passed for updated state/planning/graph/execution/tools
- `uv run python` prompt variable checks passed

---

fix(agent_v3 api): pass structured current_alert into graph input state

Fixes incorrect direct-answer behavior ("There is no alert currently selected")
when frontend clearly provides selected alert context.

Root cause:
- /agent/chat only injected alert context into enriched message text.
- agent_v3 runtime state expected `current_alert` in structured input schema.
- Missing structured field caused default/empty current_alert in graph nodes.

Changes:
- backend/api/routers/agent.py
  - when `agent_mode == "v3"` and `alert_context` exists, add
    `input_state["current_alert"]` with mapped fields:
    - alert_id, ticker, start_date, end_date, buy_qt, sell_qt
  - keep v1/v2 behavior untouched by guarding on agent_mode
  - safely coerce alert id to int when possible

Validation:
- `python3 -m py_compile backend/api/routers/agent.py` passed

---

fix(agent_v3): prevent planner/master no-op recursion loops

Fixes GraphRecursionError caused by planner returning `plan_action=reuse` with
no actionable pending steps, which repeatedly routed master->planner.

Changes:
- backend/agent_v3/planning.py
  - coerce `reuse` -> `append` when current state has no pending/running steps
  - add fallback synthetic step when append/replace returns empty step list
    to avoid no-op planning loops
- backend/agent_v3/graph.py
  - add master-side stop condition:
    if planner already ran for current question and state still has no steps,
    route to `respond` with terminal_error instead of replanning indefinitely

Validation:
- `python3 -m py_compile backend/agent_v3/planning.py backend/agent_v3/graph.py` passed
- `uv run python` graph import smoke check passed

---

feat(agent_v3 planner): expose tool capabilities + artifact knowledge with schema guardrail

Improves planner quality by giving it capability/context visibility while keeping
planner outputs intent-only, and adds a deterministic preflight injection for
SQL-like tasks when schema grounding is missing.

Changes:
- backend/agent_v3/planning.py
  - pass `tool_descriptions` and `artifact_knowledge` into planner prompt context
  - add SQL-intent detection on planned steps
  - add deterministic schema-grounding step injection:
    - prepends a step to read `artifacts/DB_SCHEMA_REFERENCE.yaml` when
      SQL/data-query intent exists and no schema step is present in existing/new steps
  - apply guardrail for both append and replace plan actions
- backend/agent_v3/prompts/planner.yaml
  - explicitly instruct planner to use tool capabilities for planning decisions
  - add artifact context (`artifacts/*`) and available tool list sections

Validation:
- `python3 -m py_compile backend/agent_v3/planning.py` passed
- `uv run python` planner prompt variables check passed

---

feat(agent_v3 execution): retry once on empty SQL result (no-data path)

Adds a controlled retry path when execute_sql succeeds but returns zero rows,
so the LLM gets one chance to adjust query arguments before finalizing.

Changes:
- backend/agent_v3/execution.py
  - add `_is_empty_sql_success` detection for successful SQL calls with 0 rows
  - add `_has_no_data_retry` guard to ensure this path retries only once
  - on first empty SQL result:
    - append retry_history entry with `error_code=NO_DATA`
    - set retry context (`last_error_code=NO_DATA`) and retry same step with execute_sql
  - keep existing max-attempt and error handling behavior unchanged
- backend/agent_v3/prompts/execution.yaml
  - add NO_DATA guidance: revise SQL to be less restrictive while preserving business intent and read-only SELECT safety

Validation:
- `python3 -m py_compile backend/agent_v3/execution.py` passed
- `uv run python` execution prompt variables check passed

---

fix(agent_v3 context): pass buy/sell quantities from frontend into current_alert state

Fixes current_alert quantity fields always being zero during agent reasoning.

Root cause:
- Frontend `alert_context` payload did not include quantity fields.
- Backend v3 input mapping hardcoded `buy_qt`/`sell_qt` to `0`.

Changes:
- frontend/src/features/agent/composables/useAgentChat.js
  - include `buy_qt` and `sell_qt` in `alert_context` payload
  - map from available alert detail keys with fallbacks:
    `buy_qt || buy_quantity || buyQty`, `sell_qt || sell_quantity || sellQty`
- backend/api/routers/agent.py
  - extend `AlertContext` model with optional quantity fields:
    `buy_qt`, `sell_qt`, `buy_quantity`, `sell_quantity`
  - map incoming values into v3 `current_alert` using safe numeric coercion
  - remove hardcoded zero defaults in v3 input mapping path

Validation:
- `python3 -m py_compile backend/api/routers/agent.py` passed
- verified buy/sell quantity fields are now present in frontend + backend mapping

---

feat(agent_v3 planner): add requires_execution_reason for plan transparency

Adds explicit planner rationale for execution vs direct-answer decisions.

Changes:
- backend/agent_v3/state.py
  - add `plan_requires_execution_reason` to AgentV3State
- backend/agent_v3/planning.py
  - extend `Plan` schema with `requires_execution_reason`
  - set deterministic reason for direct state-only fallback path
  - include execution reason in planner-visible plan text
  - persist reason back into state (`plan_requires_execution_reason`)
- backend/agent_v3/prompts/planner.yaml
  - update output contract to require `requires_execution_reason`

Validation:
- `python3 -m py_compile backend/agent_v3/state.py backend/agent_v3/planning.py` passed
- `uv run python` planner prompt variable check passed

---

fix(agent_v3 master): prioritize new user question over stale terminal_error

Fixes follow-up turns being routed straight to `respond` (skipping planner)
when previous turn left `terminal_error` set.

Changes:
- backend/agent_v3/graph.py
  - reorder master-node checks so new question detection runs before
    terminal_error short-circuit
  - keep existing behavior to clear terminal_error when routing to plan

Impact:
- follow-up questions now re-enter planner reliably
- avoids stale failure state blocking subsequent planning/execution turns

Validation:
- `python3 -m py_compile backend/agent_v3/graph.py` passed

---

fix(agent_v3 tracing): replace pydantic structured-output classes with JSON schemas

Eliminates stream/tracer serialization warnings like:
`Trying to load an object that doesn't implement serialization` for
`backend.agent_v3.planning.Plan` and `backend.agent_v3.execution.ExecutionProposal`.

Changes:
- backend/agent_v3/planning.py
  - switch `with_structured_output(Plan)` to `with_structured_output(PLAN_RESPONSE_SCHEMA)`
  - add strict JSON schema (`additionalProperties: false`) for planner output
  - parse/validate returned dict using local `Plan.model_validate(...)` fallback
- backend/agent_v3/execution.py
  - remove pydantic class-based structured output for execution proposal
  - switch to `with_structured_output(EXECUTION_PROPOSAL_SCHEMA)`
  - normalize returned dict fields (`tool_name`, `tool_args_json`, `reason`)

Validation:
- `python3 -m py_compile backend/agent_v3/planning.py backend/agent_v3/execution.py` passed
- prompt variable checks passed for planner/execution templates

---

fix(agent_v3 schema): add top-level titles to JSON schemas for structured output

Fixes Azure/LangChain `Unsupported function` error when converting JSON schema
to function format for `with_structured_output`.

Root cause:
- JSON schemas passed to `with_structured_output` lacked top-level `title`.
- Function-conversion path requires a top-level function name.

Changes:
- backend/agent_v3/planning.py
  - add `title: "PlannerResponse"` to `PLAN_RESPONSE_SCHEMA`
- backend/agent_v3/execution.py
  - add `title: "ExecutionProposal"` to `EXECUTION_PROPOSAL_SCHEMA`

Validation:
- `python3 -m py_compile backend/agent_v3/planning.py backend/agent_v3/execution.py` passed
- schema title smoke check passed

---

fix(agent_v3 respond): scope completed/failed step context to current plan version

Prevents stale errors (and stale outputs) from older plans leaking into final
responses for new follow-up questions.

Changes:
- backend/agent_v3/graph.py
  - add step-id plan version parser (`vN_sM`)
  - filter `_failed_step_payloads` to include only steps from `state.plan_version`
  - filter `_completed_step_payloads` to current plan version for consistency
  - keep backward compatibility: legacy step ids without `vN_` are included

Impact:
- limitation notes now reflect current ask execution only
- successful current turns no longer inherit historical technical-issue notes

Validation:
- `python3 -m py_compile backend/agent_v3/graph.py` passed

---

feat(agent_v3 history): hide intermediate planner output after refresh

Keeps planner output visible during live streaming, but removes it from
persisted chat-history rendering so intermediate node output does not appear
after page refresh.

Changes:
- backend/agent_v3/planning.py
  - tag planner AI message with `additional_kwargs={"ephemeral_node_output": "planner"}`
- backend/api/routers/agent.py
  - skip assistant messages marked with `ephemeral_node_output` while building
    `/agent/history` response payload

Behavior:
- live session: planner text still streams to UI
- after refresh/history reload: planner intermediate text is hidden
- final responder output remains visible

Validation:
- `python3 -m py_compile backend/agent_v3/planning.py backend/api/routers/agent.py` passed

---

fix(agent stream/ui): keep tool input preview JSON parseable so truncated Python code still renders

Problem:
- Successful `execute_python` calls often carry long `code` inputs.
- Backend preview logic truncated the serialized JSON blob at a character boundary,
  producing invalid JSON.
- Frontend tool panel parses `tool.input` as JSON before showing `Python Code`, so
  invalid JSON caused code blocks to disappear on successful runs.

Changes:
- backend/api/routers/agent.py
  - update `_safe_preview` to preserve parseable JSON for dict/list inputs
  - truncate long leaf string values (e.g., `code`, `query`) instead of truncating
    the full serialized JSON string
  - keep fallback truncation behavior for non-JSON primitive/string payloads

Impact:
- Python and SQL tool cards now show truncated code consistently on successful runs.
- Tool commentary and code-copy behavior remains unchanged.

Validation:
- `python3 -m py_compile backend/api/routers/agent.py` passed

---

fix(ui tool trace): decode double-encoded tool inputs so Python code renders on success

Problem:
- Some `tool_start.input` payloads arrive double-encoded (JSON string containing
  JSON object text).
- Tool panel parser decoded once and expected an object, so code block rendering
  was skipped for successful `execute_python` calls.

Changes:
- frontend/src/features/agent/components/AgentPanelFeature.vue
  - update `parseToolInput` to attempt a second JSON decode when first decode
    returns a string
  - broaden Python code key fallback in `toolCode` to support `code`,
    `python_code`, and `script`

Impact:
- `Python Code` now appears more consistently for successful tool calls.

---

feat(agent_v3 memory): add token-budget context manager with conversation summary memory

Summary:
- Added a pre-master `context_manager` node to track conversation token size and
  compress older turns into a persistent summary when context grows too large.
- Trigger threshold is 50k tokens; summary is merged and stored in state.

State changes:
- backend/agent_v3/state.py
  - add `conversation_summary`
  - add `summary_version`
  - add `last_summarized_message_index`
  - add `token_estimate`

Graph/orchestration changes:
- backend/agent_v3/graph.py
  - add `context_manager` node
  - wire flow: `START -> ensure_system_prompt -> context_manager -> master`
  - add token estimation (tiktoken with heuristic fallback)
  - add summary generation prompt for old-message chunks while preserving recent
    message window

Prompt-context changes:
- backend/agent_v3/utilis.py
  - add `build_prompt_messages(...)` helper to inject summary + recent window
- backend/agent_v3/planning.py
  - planner now receives summary-aware prompt messages
  - pass `conversation_summary` variable into planner prompt
- backend/agent_v3/execution.py
  - executioner now receives summary-aware prompt messages
  - pass `conversation_summary` variable into execution prompt
- backend/agent_v3/prompts/planner.yaml
  - include `Prior conversation summary` context slot
- backend/agent_v3/prompts/execution.yaml
  - include `Prior conversation summary` context slot

Dependencies:
- pyproject.toml
  - add `tiktoken>=0.9.0`

Validation:
- `python3 -m py_compile backend/agent_v3/state.py backend/agent_v3/utilis.py backend/agent_v3/planning.py backend/agent_v3/execution.py backend/agent_v3/graph.py` passed

---

feat(debug telemetry): expose context-memory token summary status in stream + UI

Goal:
- Surface context-manager memory telemetry (token estimate + summary status)
  without breaking other agent versions.

Backend changes:
- backend/api/routers/agent.py
  - add `_extract_context_debug_payload(...)` parser for `context_manager` chain-end output
  - emit SSE event `type: context_debug` with:
    - `active`
    - `token_estimate`
    - `summary_version`
    - `summarization_triggered`
  - event is emitted only when context-manager payload is present

Frontend changes:
- frontend/src/features/agent/composables/useAgentChat.js
  - add `contextDebug` reactive state
  - parse `context_debug` SSE events
  - reset debug state at start of each ask
- frontend/src/features/agent/components/AgentPanelFeature.vue
  - add small debug strip under header showing:
    - active/inactive
    - token estimate (or null)
    - summary version (or null)
    - triggered yes/no

Compatibility behavior:
- If another agent version does not emit `context_debug`, UI remains:
  - `active = false`
  - `tokenEstimate = null`
  - `summaryVersion = null`
  - `summarizationTriggered = false`

Validation:
- `python3 -m py_compile backend/api/routers/agent.py` passed
